函数式编程特性有几个：闭包，迭代器，模式匹配，枚举。这里重点学习闭包和迭代器。



## 1 闭包

闭包是**一种匿名函数，它可以赋值给变量也可以作为参数传递给其它函数，不同于函数的是，它允许捕获调用者作用域中的值**



### 三种Fn 特征

闭包捕获变量的三种途径：转移所有权、可变借用、不可变借用

1. FnOnce 捕获变量的所有权。
2. FnMut 可变借用环境的值
3. Fn 不可变借用环境中的值

### 闭包作为返回值

### 闭包的生命周期



## 2 迭代器



### 2.1 惰性初始化

创建迭代器是不会有性能损耗，不使用没有任何变化。

### 2.2  into_iter, iter, iter_mut

- `into_iter` 会夺走所有权
- `iter` 是借用
- `iter_mut` 是可变借用

### 2.3 消费器与适配器

#### 消费器

只要在迭代器中的某个方法A 调用了next方法，那么A 就是消费器适配器。

因为next方法会消耗迭代器上的元素，所以A的调用也会消耗迭代器上的元素。

```rust
// 以sum方法为例子：
fn main() {
    let v1 = vec![1,2,3];
    let v1_iter = v1.iter();
    let total: i32 = =v1_iter.sum();
    // vi_iter 是借用v1， v1是可以照常使用的
    // 以下代码会报错，因为 `sum` 拿到了迭代器 `v1_iter` 的所有权
    // println!("{:?}",v1_iter);
}
```

```rust
// sum
fn sum<S>(self) -> S
	where
		Self: sized,
        S: Sum<Self::Item>,
	{
        Sum::sum(self)
}
// self 方法拿走了所有权
```

#### 适配器

消费器是消耗掉迭代器，然后返回一个值。那么迭代器适配器，会返回一个新的迭代器。实现链式调用的关键： `v.iter().map().filter()...`